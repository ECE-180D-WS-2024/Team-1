import random
import copy
from typing import Tuple

from direct.interval.IntervalGlobal import Sequence
from panda3d.core import TextNode, NodePath

from puzzles import Puzzle


# Define the manual with sequences for each row
MANUAL = [ 
    ['u', 'l', 'o', 'x', 's', 'd', 'v', 'b'],
    ['j', 't', 'w', 'v', 'h', 'z', 'p', 'y'],
    ['i', 'x', 'q', 'y', 'm', 'g', 'j', 't'],
    ['i', 'c', 'r', 'a', 'm', 'j', 'h', 'd'],
    ['r', 'y', 'c', 'e', 's', 'w', 'i', 'g']
]

randomized_ordering = []
row_n = -1
btn_depressed = [False] * 4

btn_texts = []

def __get_btn_np(bomb_np: NodePath, btn_coord: Tuple[int, int]) -> NodePath:
    i, j = btn_coord
    return bomb_np.find(f'**/seq.btn{i}{j}')


def __render_btn_symbol(bomb_np: NodePath, btn_coord: Tuple[int, int], text):
    btn_np = __get_btn_np(bomb_np, btn_coord)
    text_np = btn_np.attachNewNode(text)
    text_np.setPos(0.2, 1.1, -0.1)
    text_np.setHpr(0, 180, 180)

def __btn_coord_to_arr_idx(btn_coord: Tuple[int, int]) -> int:
    i, j = btn_coord
    return (i * 2) + j

def init(app):
    coords = {(0,0), (0,1), (1,0), (1,1)}
    for coord in coords:
        text = TextNode(name=f'seq_btn{coord[0]}{coord[1]}')
        text.setTextScale(0.75)
        text.setTextColor(0, 0, 0, 1)
        btn_texts.append(text)
        __render_btn_symbol(app.bomb, coord, text)

    generate_puzzle()

def generate_puzzle():
    global key
    global randomized_ordering
    global row_n
    global btn_depressed

    row_n = random.randint(0, 4)  # Randomly select a row from the manual
    shuffled_row = copy.deepcopy(MANUAL[row_n])  # Deep copy the selected row
    random.shuffle(shuffled_row)  # Shuffle the row to create a key
    randomized_ordering = shuffled_row[:4]

    # Key is generated by filtering the selected row's elements for the ones randomly chosen, 
    # then putting them in reverse order according to their original position in the manual's row
    key = list(sorted(filter(lambda x: x in randomized_ordering, MANUAL[row_n]), key=lambda x: MANUAL[row_n].index(x), reverse=True))

    for i, ch in enumerate(randomized_ordering):
        btn_text = btn_texts[i]
        btn_text.setText(ch)
    

def focus(app):
    app.bomb.hprInterval(0.25, (180, 0, 0)).start()
    app.focused = Puzzle.SEQUENCE

def press_btn(app, btn_coord, initial_pos):
    btn = __get_btn_np(app.bomb, btn_coord)
    x, y, z = initial_pos

    press_interval = btn.posInterval(0.2, (x, y - 0.1, z))
    release_interval = btn.posInterval(0.2, (x, y, z))

    btn_index = __btn_coord_to_arr_idx(btn_coord)
    if not btn_depressed[btn_index]:
        btn_symbol = randomized_ordering[btn_index]
        if key[0] == btn_symbol:
            press_interval.start()
            key.pop(0)
            btn_depressed[btn_index] = True
        else:
            Sequence(press_interval, release_interval).start()
            app.handle_mistake()
    
    if all(btn_depressed):
        app.solve_puzzle(Puzzle.SEQUENCE)
