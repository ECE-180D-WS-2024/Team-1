import random
import copy
from typing import Tuple

from direct.interval.IntervalGlobal import Sequence
from panda3d.core import TextNode, NodePath


# Define the manual with sequences for each row
MANUAL = [ 
    ['u', 'l', 'o', 'x', 's', 'd', 'v', 'b'],
    ['j', 't', 'w', 'v', 'h', 'z', 'p', 'y'],
    ['i', 'x', 'q', 'y', 'm', 'g', 'j', 't'],
    ['i', 'c', 'r', 'a', 'm', 'j', 'h', 'd'],
    ['r', 'y', 'c', 'e', 's', 'w', 'i', 'g']
]

randomized_ordering = []
row_n = -1
btn_depressed = [False] * 4

def __get_btn_np(bomb_np: NodePath, btn_coord: Tuple[int, int]) -> NodePath:
    i, j = btn_coord
    return bomb_np.find(f'**/seq.btn{i}{j}')

def __render_btn_symbol(bomb_np: NodePath, btn_coord: Tuple[int, int], symbol: str):
    text = TextNode(name=f'seq_btn{btn_coord[0]}{btn_coord[1]}')
    text.setText(symbol)
    text.setTextScale(0.75)
    text.setTextColor(0, 0, 0, 1)

    btn_np = __get_btn_np(bomb_np, btn_coord)
    text_np = btn_np.attachNewNode(text)
    text_np.setPos(0.2, 1.1, -0.1)
    text_np.setHpr(0, 180, 180)

def __btn_coord_to_arr_idx(btn_coord: Tuple[int, int]) -> int:
    i, j = btn_coord
    return (i * 2) + j

def init(app):
    global key
    global randomized_ordering
    global row_n
    global btn_depressed

    row_n = random.randint(0, 4)  # Randomly select a row from the manual
    shuffled_row = copy.deepcopy(MANUAL[row_n])  # Deep copy the selected row
    random.shuffle(shuffled_row)  # Shuffle the row to create a key
    randomized_ordering = shuffled_row[:4]

    # Key is generated by filtering the selected row's elements for the ones randomly chosen, 
    # then putting them in reverse order according to their original position in the manual's row
    key = list(sorted(filter(lambda x: x in randomized_ordering, MANUAL[row_n]), key=lambda x: MANUAL[row_n].index(x), reverse=True))

    __render_btn_symbol(app.bomb, (0, 0), randomized_ordering[0])
    __render_btn_symbol(app.bomb, (0, 1), randomized_ordering[1])
    __render_btn_symbol(app.bomb, (1, 0), randomized_ordering[2])
    __render_btn_symbol(app.bomb, (1, 1), randomized_ordering[3])

def focus(bomb_np: NodePath):
    bomb_np.hprInterval(0.25, (180, 0, 0)).start()

def press_btn(app, btn_coord, initial_pos):
    btn = __get_btn_np(app.bomb, btn_coord)
    x, y, z = initial_pos

    press_interval = btn.posInterval(0.2, (x, y - 0.1, z))
    release_interval = btn.posInterval(0.2, (x, y, z))

    btn_index = __btn_coord_to_arr_idx(btn_coord)
    if not btn_depressed[btn_index]:
        btn_symbol = randomized_ordering[btn_index]
        if key[0] == btn_symbol:
            press_interval.start()
            key.pop(0)
            btn_depressed[btn_index] = True
        else:
            Sequence(press_interval, release_interval).start()
            app.handle_mistake()
